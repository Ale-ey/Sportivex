---
alwaysApply: true
---
 "Design and Modelling: Use proper software design principles such as modularity, cohesion, and separation of concerns. 
            "Specifications: Define preconditions and postconditions for all public functions. Use declarative specifications when defining outcomes, and operational specifications when detailing step-by-step behavior. Document all constraints and expected results for clarity.",
            "Mutability: Minimize mutable state where possible; prefer immutability for safety and predictability. Clearly document mutable variables and their risks. Ensure all mutations respect defined contracts and invariants.",
            "Recursion: Prefer recursion where it simplifies problem-solving or when working with recursive data structures. Ensure each recursive function has a clear base case and smaller subproblem. Avoid redundant recursive calls and ensure tail recursion where possible. Implement recursion if suitable and recommended for the task.",
            "Abstraction: Design with abstract data types (ADTs) to hide implementation details. Maintain representation invariants and abstraction barriers. Use interfaces and abstract classes in Java (or equivalent constructs) to define contracts. Replace preconditions with ADT invariants where applicable.",
            "Parsing: If parsing text or code, use a parser generator like ANTLR. Define grammars cleanly, construct abstract syntax trees (ASTs), and handle parse errors gracefully. Implement traversals for parse trees and generate structured output.",
            "Concurrency: When implementing concurrency, avoid race conditions and shared mutable state. Prefer message passing or async models over locking where possible. Be aware that concurrency is hard to test and debug; use thread-safe structures and synchronization primitives properly.",
            "Little Languages: Encapsulate domain-specific logic into small, well-defined languages or configuration systems. Represent code as data where applicable. Use version control effectively for collaboration â€” commit often, use branches, and maintain readable commit history.",
            "Debugging: Design systems to minimize debugging needs through assertions and tests. When bugs occur, reproduce them consistently, then localize and understand the root cause before fixing. Document debugging steps and use logs for insight.",
            "Static Checking and Testing: Use static analysis tools to catch errors early. Follow test-first or test-driven development (TDD) practices. Include both black-box . Choose test cases by partitioning input spaces. Ensure all modules have unit tests with sufficient coverage."